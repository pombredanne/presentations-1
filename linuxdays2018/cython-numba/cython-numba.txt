Rešení problematiky pomalých aplikací v Pythonu
      s využitím nástrojů Cython a Numba
==================================================
■ Autor    Pavel Tišnovský, Red Hat
■ Email    <ptisnovs 0x40 redhat 0x2e com>
■ Datum    2018-09-xx

Obsah přednášky (1)
--------------------------------------------------
▶ Programovací jazyk Python
▶ Implementace Pythonu
▶ Bajtkód Pythonu a jeho interpretace
▶ Intuitivní odhad rychlejšího kódu?
▶ Céčkový kód s přesnými informacemi o typu
▶ Problematika překladu Pythonu do nativního kódu
▶ Nástroj Cython
▶ Nástroj Numba
▶ Výsledky benchmarků
▶ Další možnosti - Jython atd.

Programovací jazyk Python
--------------------------------------------------
▶ Dnes jeden z nejpopulárnějších jazyků
▶ Dostupnost na většině platforem
    ◆ na některých MCU jako MicroPython
▶ Použití
    ◆ Nástroje a utility ovládané z příkazového řádku
    ◆ Aplikace s grafickým uživatelským rozhraním
    ◆ Client-server
        serverová část (Flask, Django, ...)
    ◆ Numerické výpočty, symbolické výpočty
        Numpy
        SciPy
        Matplotlib
    ◆ Moderní způsoby využití Pythonu
        AI
        Machine Learning (Deep Learning)
        Big data
    ◆ Tzv. "glue" jazyk

Implementace Pythonu
--------------------------------------------------
▶ Nejpoužívanější implementace
    ◆ CPython
    ◆ Pypy
    ◆ Jython
    ◆ Iron Python
▶ Další implementace
    ◆ Psyco
    ◆ Stackles Python
    ◆ MicroPython
▶ Speciální implementace
    ◆ Cython
    ◆ RPython
    ◆ Numba
        - právě ty nás dnes budou zajímat

Bajtkód Pythonu a jeho interpretace
--------------------------------------------------
▶ Překlad do bajtkódu před spuštěním skriptů
    ◆ explicitně
    ◆ automaticky
▶ Je možné částečně ovlivnit volbami
    ◆ -O
        • optimalizace bajtkódu
    ◆ -OO
        • odstranění komentářů
▶ Vlastnosti bajtkódu Pythonu (CPythonu)
    ◆ vysokoúrovňový
        • například v porovnání s JVM
    ◆ malá sémantická mezera Python:bajtkód
        • velký rozdíl oproti C:asm či C:strojový kód
    ◆ používá zásobník operandů
        • podobně: JVM
        • jinak: LuaVM, CLR

Instrukce bajtkódu
--------------------------------------------------
▶ Práce se zásobníkem operandů
    ◆ polymorfní chování!
▶ Unární operátory
▶ Binární operátory
▶ Zkrácené binární operátory "inplace" +=
▶ Přístup k prvkům složeného datového typu
    ◆ řetězec, seznam, n-tice
    ◆ polymorfní chování!
▶ Operace s prvky seznamů
▶ Operace s mapou (slovníkem)
▶ Iterátory
▶ Příkaz/funkce print
▶ Řízení běhu programu
▶ Konstrukce objektu, vytvoření funkce
▶ Vytvoření uzávěru
▶ Vyhození výjimky, zachycení výjimky

Bajtkód Pythonu a jeho interpretace
--------------------------------------------------
▶ Instrukce nenesou informace o datovém typu operandů
    ◆ de facto dynamické typování na úrovni VM
▶ Příklad funkce napsané pro různé typy parametrů
        def add(x, y):
            return x+y
▶ Bajtkód
add:
        0 LOAD_FAST           0 (x)
        3 LOAD_FAST           1 (y)
        6 BINARY_ADD
        7 RETURN_VALUE

Intuitivní odhad rychlejšího kódu?
--------------------------------------------------
▶ Kvůli vysokoúrovňovému bajtkódu je odhad složitý
    První verze jednoduché smyčky s počitadlem
        for i in range(x):
            pass
    Druhá verze smyčky
        i = 0
        while i < x:
            i += 1
    Druhá smyčka
        žádné "složité" objekty
        teoreticky překlad do MOV, ADD/INC, CMP, JNZ
        skutečnost je ovšem jiná!

Intuitivní odhad rychlejšího kódu?
--------------------------------------------------
▶ Jednoduchý benchmark
    První verze smyčky
        timeit.timeit('for i in range(100): pass')
        1.7635615249964758
    Druhá verze smyčky
        timeit.timeit('i = 0\nwhile i < 100: i += 1')
        5.507031249995634

Intuitivní odhad rychlejšího kódu?
--------------------------------------------------
▶ Analýza bajtkódu
    První verze
              0 SETUP_LOOP              20 (to 23)
              3 LOAD_GLOBAL              0 (range)
              6 LOAD_CONST               1 (100)
              9 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             12 GET_ITER
        >>   13 FOR_ITER                 6 (to 22)
             16 STORE_FAST               0 (i)
 
             19 JUMP_ABSOLUTE           13
        >>   22 POP_BLOCK
        >>   23 LOAD_CONST               0 (None)
             26 RETURN_VALUE

Intuitivní odhad rychlejšího kódu?
--------------------------------------------------
▶ Analýza bajtkódu
    Druhá verze smyčky
              0 LOAD_CONST               1 (0)
              3 STORE_FAST               0 (i)
 
              6 SETUP_LOOP              26 (to 35)
        >>    9 LOAD_FAST                0 (i)
             12 LOAD_CONST               2 (100)
             15 COMPARE_OP               0 (<)
             18 POP_JUMP_IF_FALSE       34
 
             21 LOAD_FAST                0 (i)
             24 LOAD_CONST               3 (1)
             27 INPLACE_ADD
             28 STORE_FAST               0 (i)
             31 JUMP_ABSOLUTE            9
        >>   34 POP_BLOCK
        >>   35 LOAD_CONST               0 (None)
             38 RETURN_VALUE

Céčkový kód s přesnými informacemi o typu
--------------------------------------------------
▶ Jednoduchá funkce vracející součet svých parametrů
    ◆ v céčku přímočarý zápis s plnou typovou informací
        int add(int x, int y)
        {
            return x+y;
        }
    ◆ překladač má k dispozici
        • přesný počet a typ parametrů (alokace na zásobníku)
        • návratový typ funkce
        • případné další informace (statická funkce?)

Céčkový kód s přesnými informacemi o typu
--------------------------------------------------
▶ Překlad bez optimalizací
gcc -O0 -c -S -fno-asynchronous-unwind-tables test.c
    ◆ vygenerovaný kód (v assembleru)
        add:
            pushq   %rbp
            movq    %rsp, %rbp
            movl    %edi, -4(%rbp)
            movl    %esi, -8(%rbp)
            movl    -8(%rbp), %eax
            movl    -4(%rbp), %edx
            addl    %edx, %eax
            popq    %rbp
            ret
    ◆ nic moc že?

Céčkový kód s přesnými informacemi o typu
--------------------------------------------------
▶ Překlad s optimalizacemi
gcc -O0 -c -S -fno-asynchronous-unwind-tables test.c
    ◆ vygenerovaný kód (v assembleru)
        add:
            leal    (%rdi,%rsi), %eax
            ret
▶ Lze dosáhnout podobného výsledku i pro Python?

Problematika překladu Pythonu do nativního kódu
--------------------------------------------------
▶ Dynamický typový systém
    def add(x, y):
        return x + y
▶ Je korektní transformovat do
    int add(x, y) {
        return x + y;
    }
    ◆ ???

Problematika překladu Pythonu do nativního kódu
--------------------------------------------------
▶ Ve skutečnosti lze add použít prakticky pro libovolné typy parametrů
    ◆ 123 + 456
    ◆ 123. + 456
    ◆ "hello " + "world"
    ◆ (1,2,3) + (4,5,6)
    ◆ [1,2,3] + [4,5,6]
    ◆ True + True  (uff!)
    ◆ Kdykoli v budoucnu může někdo vytvořit třídu
      s __add__ nebo __radd__

Problematika překladu Pythonu do nativního kódu
--------------------------------------------------
▶ Možná řešení
    ◆ Typové informace dostupné při překladu
        - RPython
        - Cython
        - různé přístupy (explicitní zápis, analýza)
    ◆ JIT překlad s nebo bez typových informací

Nástroj RPython
--------------------------------------------------
▶ Založen na analýze grafu toku (CFG)
▶ Snaha o automatické odvození datových typů
▶ Nutná omezení v samotném jazyce!
    ◆ V žádném případě se nejedná o klasický Python
        - prakticky vše musí jít odvodit v čase překladu
        - (ne dynamicky definované třídy, funkce, ...)
    ◆ Projekt určený především pro tvůrce překladačů/runtime
    ◆ Použití běžnými vývojáři dosti nepohodlné
        - dlouhý překlad
        - někdy nepříliš jasná chybová hlášení

Použití nástroje RPython
--------------------------------------------------
▶ V naprosté většině případů interpretry nebo implementace VM
    ◆ PyPy
    ◆ Pydgin
    ◆ RSqueak VM
    ◆ Pixie
    ◆ Monte
    ◆ Typhon
    ◆ Tulip
    ◆ Pycket
    ◆ Lever

Nástroj Cython
--------------------------------------------------
▶ *** Pozor: Cython != CPython ***
▶ Vznikl z projektu Pyrex
▶ Nadmnožina programovacího jazyka Python
▶ Umožňuje překlad do nativního kódu
    ◆ Transpřeklad Cython -> C
    ◆ Překlad C -> nativní kód (GCC, Clang...)
▶ Výsledek překladu
    ◆ (nativní) modul pro Python
    ◆ Běžná spustitelná aplikace
▶ Volitelně lze použít explicitní určení typů
    ◆ Mnohem vyšší efektivita generovaného kódu
▶ Další možnosti vedoucí k urychlení výsledku
 ◆ Odstranění volání GIL
 ◆ Céčkové implementace funkcí typu print
 ◆ Pole

Nástroj Cython
---------------------------------------

Nástroj Numba
--------------------------------------------------
▶ Překladač Pythonu do nativního kódu (i pro CUDA)
    ◆ Just-in-time (JIT)
    ◆ Ahead-of-time (AOT)
▶ Označení funkcí/metod, které se mají JITovat 
    ◆ Odvození datových typů až v čase běhu aplikace
▶ Backend používá LLVM

Označení funkcí pro JITování
--------------------------------------------------
        from numba import jit
        @jit
        def funkce1():
            pass

Numba a funkce print
--------------------------------------------------
▶ „univerzální“ pythonovská varianta
▶ 

Výsledky benchmarků
--------------------------------------------------
▶ CPython 2,3 versus 
    ◆ Jython
    ◆ RPython
    ◆ Cython (bez úprav)
    ◆ Cython (typy)
    ◆ Cython (plná optimalizace)
    ◆ ANSI C (samozřejmě kompletně přepsáno)
▶ Numba
    ◆ Interpret s původním kódem
    ◆ Kód, do něhož byla pouze přidána anotace @jit
    ◆ Varianta s jednodušší (nativní) funkcí print
    ◆ Varianta s jednodušší (nativní) funkcí print a anotací @jit(nopython=True)
▶ Interpret vs Cython vs Numba vs ANSI C
    ◆ Ukazuje delší čas startu Numby vs. lepší optimalizace
    ◆ křivky pro ANSI C a Cython s plnou optimalizací se překrývají!

Další možnosti - Jython atd.
--------------------------------------------------

