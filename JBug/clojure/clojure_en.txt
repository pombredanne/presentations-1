Clojure - LISP on JVM
=====================
:author  Pavel Tišnovský
:email   <ptisnovs 0x40 redhat 0x2e com>
:date    2017-05-03

Agenda
------
▶ Clojure - (not) yet another language for JVM
▶ Basic Clojure features
▶ Forms
▶ Collections
▶ Functions
▶ Lazy evaluation and lazy sequences
▶ Four reference types (variable substitution)
▶ Parallel programming
▶ Watchers
▶ Validators
▶ Macros
▶ Classes and objects in Clojure
▶ Cooperation between Java and Clojure
▶ Web apps (Clojure Ring philosophy)
▶ Testing
▶ Code coverage reporting

Clojure - (yet another) language for JVM
----------------------------------------
Java Virtual Machine
Specification implemented by more VMs
    HotSpot
        Client
        Server
    Azul
    J9
    JamVM
    CACAO VM
    Graal
    Jikes RVM

JVM
---
JVM is scalable
    No (apparent) GIL
    Multi-threaded garbage collectors
    Synchronized and unsynchronized variants of collections
    Future interface
etc. etc. etc.
Supports dynamically typed programming languages

Java platform
-------------
Compiler+JVM+standard packages+other tools
Mature
    evolving since 1985 now > 14M developers (TIOBE)
Stable and robust + rich standard libraries
Usually backward compatible
    "Java is a modern COBOL"

Java is not the only language prepared to run on JVM
-----------------------------------------------------
JavaScript
    Rhino
    Nashorn
Scala
Groovy
Jython
JRuby
Kotlin
...
...
...
Clojure!

Java vs.Clojure?
----------------
Java vs. Clojure? not exactly...
Clojure is not replacement of Java
    does not try to reinvent the wheel
    cooperates nicely with Java libs
        "Java interop"

Clojure
-------
▶ Clojure = Java + Closure
▶ Rich Hickey
▶ Based on LISP (and on Scheme too)
    ◆ Theory of λ-calculus
        Alonzo Church
        Look at the Clojure logo :)
    ◆ WEB2.0^W cloud^W social networks^W^W AI was the IT buzzword in 1950s
    ◆ John McCarthy 1956-1958
    ◆ Implemented by S.R.Russell (REPL)

Basic Clojure features
----------------------
Deadlock-free multi-threaded programs
    Immutable data types
        List (linked), vector (RRB Tree), hash map, set
        very important feature in massive parallel applications
    Agents
    Software Transactional Memory (STM)
        Support for transactions
Clojure contains REPL
    Read-Eval-Print-Loop
Code == Data
    -> Homoiconicity
    Well, Clojure is a LISP variant...

Basic Clojure features
----------------------
Four reference types instead of simple "variables"
    variables are a poor choice for many operations
    sync/async operations
    atomic operations
    regular variable can't be "watched"
    regular variable can't be validated simply

Basic Clojure features
----------------------
Lambda expressions
Closures
Explicit tail recursion
Clojure is lazy
    ie it is like many humans (incl. /me)
    Performs required work only when forced/asked
    Lazy sequences
        range function is a good example
    Some work (computation) does not have to be performed ASAP
        Let's start it in a background thread!

Java <--> Clojure communication
-------------------------------
Clojure can create an instance of a Java class and access its attributes and methods
    JSR-292 support
Programs are compiled into JVM bytecode
    On the fly
        The best of "scripted" and "compiled" worlds :-)
    With support for dynamic typing 
        Not an easy task (before invokedynamic)

Namespaces
----------
namespace/name
ns macro
no real "global" variables

Forms
-----
Literals
    Numbers
    Strings
    Boolean values
    Symbols and keywords
Compound forms
    Lists
    Vectors
    Maps
    Sets

Special forms
-------------
Special forms
    if
    def
        creates a "global" var with the given name
    do
    new
        calls the respective constructor of the given Java class
    . (dot)
        used to call methods of Java objects
    etc.

Functions
---------
Functions have similar properties as other values
    It's possible to create new functions in runtime
    Function could be passed to other function as a parameter
    Function could be returned by other function as its return value
    Function could be stored in list, vector, map etc.
    Name could be bind to a function
        but it's not needed in all cases
        anonymous functions
        used extensivelly not only in Clojure

Anonymous functions
-------------------
Short form of anonymous function definition
Functions with name
    defn = def + fn

Referentially transparent functions
-----------------------------------
Don't access any global symbol
Without side-off effects (I/O)
Don't have internal state
    those functions are not bound to application state
    results can be cached
    (memoization)

Multiarity functions
--------------------

Lazy evaluation and lazy sequences
----------------------------------

Recursion vs tail recursion
---------------------------
Factorial - a typical example
Very deep recursion might cause stack overflow
    ''recur'' special form
    It is not possible to use ''recur'' everywhere

Collections
-----------
List, Vector, Map, Set
Immutable items
Persistent collections
    It is not neccessary to clone a collection in case of some operations
    pop/peek for lists
    ...

Basic functions for collection processing
-----------------------------------------
(count)
(empty)
(cons)
(conj)
(pop)  ; lists vs vectors
(peek) ; lists vs vectors
(nth)
(first)
(rest)

Time complexity
---------------
# Function List   Vector
1 count    O(1)   O(1)
2 nth      O(N)   O(log₃₂N)
3 pop      O(1)   O(log₃₂N)
4 peek     O(1)   O(log₃₂N)
5 first    O(1)   O(1)
6 last     O(N)   O(N)

Lists
------
Lists
    Internally constist of:
        first item
        rest (sublist)
        count
Program itself is represented by a sequence of lists!

Vectors
-------
Vectors
    used extensivelly in Clojure
    Based on RRB-Trees, Relaxed Radix Balanced Trees
    usually takes less memory than lists
        <=32 items -> simple array
        <=1024 items -> tree with height=2
            root=32 references to 32-item vectors
        <= 32768 items -> tree with height=3
            and so on...

Maps
----
~ dictionaries, hashtables
Sortable maps

Sets
----
Implemented as hash sets
Can't contain duplicate items
Sortable sets

Sequences
---------
Sequence = iterator in other languages
Three basic operations
    first
        returns the first item in the collection/sequence
    rest
        returns (possibly empty) sequence of the items after the first item
    next
        returns a sequence of items after the first item
        nil instead of empty sequence
All collections are sequences

Lazy sequences
--------------
Lazy sequence - computation is done ALAP
    range function
    repeat function
    map
        returns a lazy sequence
    take
        returns a lazy sequence of the first n items in coll
    take-while
        returns a lazy sequence of successive items from coll according to the given condition
    filter

Four reference types (variable substitution)
--------------------------------------------

Parallel programming
--------------------

Watchers
--------

Validators
----------

Macros
------

Threading macros
----------------
->
(-> "/etc/passwd" slurp clojure.string/split-lines count)
->>
(->> (range) (take 20) (filter #(zero? (mod % 3))))

Classes and objects in Clojure
------------------------------

Cooperation between Java and Clojure
------------------------------------

Web apps (Clojure Ring philosophy)
----------------------------------

Testing
-------
(ns factorial.core
  (:gen-class))
 
(defn factorial
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1 (inc n)))))
 
(defn -main
    "I don't do a whole lot ... yet."
    [& args]
    (doseq [i (range 0 10)]
        (println i "! = " (factorial i))))

Unit tests...
-------------
(ns factorial.core-test
  (:require [clojure.test :refer :all]
            [factorial.core :refer :all]))
 
(deftest factorial-test
    (testing "Factorial"
        (is ( = (factorial 0)   1) "beginning")
        (is ( = (factorial 1)   1) "beginning")
        (is ( = (factorial 2)   (* 1 2)) "still easy")
        (is ( = (factorial 5)   (* 1 2 3 4 5)) "5!")
        (is ( = (factorial 6)   720) "6!")))
 
(deftest negative-factorial-test
    (testing "Negative tests"
        (is ( = (factorial 0)   0) "negative test case #1")
        (is ( = (factorial 1)   0) "negative test case #2")
        (is ( = (factorial 2)   0) "negative test case #3")))
 
(deftest exception-test
    (testing "If factorial throws exception"
        (is (thrown? IllegalArgumentException (factorial -1)))
        (is (thrown? IllegalArgumentException (factorial -2)))
        (is (thrown? IllegalArgumentException (factorial -100)))))
 
(deftest negative-exception-test
    (testing "(negative test) If factorial throws exception"
        (is (thrown? IllegalArgumentException (factorial 1)))
        (is (thrown? IllegalArgumentException (factorial 2)))
        (is (thrown? IllegalArgumentException (factorial 3)))))

Test results
------------
FAIL in (negative-factorial-test) (core_test.clj:15)
Negative tests
negative test case #1
expected: (= (factorial 0) 0)
  actual: (not (= 1 0))

Expectations
------------
(defproject expectations-demo "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [expectations "2.0.9"]]
  :main ^:skip-aot expectations-demo.core
  :target-path "target/%s"
  :plugins [[lein-expectations "0.0.8"]]
  :profiles {:uberjar {:aot :all}})
 
(expect 42 (* 6 7))
(expect "Hello world" (str "Hello" " " "world"))
(expect 2/3 (/ 2 3))
(expect ArithmeticException (/ 1 0))

Code coverage reporting
-----------------------
(defproject cloverage "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]]
  :main ^:skip-aot cloverage.core
  :target-path "target/%s"
  :plugins [[lein-cloverage "1.0.2"]]
  :profiles {:uberjar {:aot :all}})

Documentation generation
-------------------------
(defproject codoxtest "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]]
  :main ^:skip-aot codoxtest.core
  :target-path "target/%s"
  :plugins [[codox "0.8.11"]]
  :profiles {:uberjar {:aot :all}})


