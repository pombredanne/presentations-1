Programovací jazyk Go - workshop
Linux Days 2019
Tags: golang, go

Pavel Tišnovský <ptisnovs@redhat.com>
Red Hat, Inc.



* Úvodní informace o workshopu
-
-
-



* Gophers
#The Go gopher was designed by Renee French. (http://reneefrench.blogspot.com/)
#Source https://golang.org/doc/gopher/fiveyears.jpg
#The design and this image is licensed under the Creative Commons 3.0 Attributions license.
.image ./images/fiveyears.jpg _ 900



* Vybrané cíle programovacího jazyka Go
- Jednoduchost, jednoznačnost
- Jazyk postaven na jednoduchých a známých konceptech
- Lze začít programovat po doslova několikaminutovém tutoriálu
- Bezpečné aplikace
- Mikroslužby
- Skripty a nástroje pro DevOps od DevOps
- Jazyk pro potřeby Googlu: spíše pro mladší vývojáře (C/C++, Java, Python ve škole)
- Použití pro rozsáhlejší aplikace psané velkým týmem
- Paralelní běh částí aplikace
- Rozumný výpočetní výkon: cílem je dosáhnout výkonnosti C/C++/Fortranu



* Charakteristické rysy jazyka Go
- Poučení z chyb, které najdeme například v C/C++
- Silný typový systém
- Nepoužívají se makra založená na textové substituci
- Nepoužívají se hlavičkové soubory
- Bezpečná práce s pamětí (+ GC)
- Standardizovaný framework pro testování
- Rychlé překlady
- Syntaktické věci: ++/-- jen postfixové a nejsou to výrazy
- Nepoužívá se ukazatelová aritmetika
- Nepoužívají se šablony
- Nejsou podporovány výjimky (prozatím)



* Důležité vlastnosti Go

- Správa paměti se přenáší do runtime
- Gorutiny a kanály (600k gorutin, 90% CPU)
- Více imperativních rysů: explicitní zápis většiny operací
- Více pragmaticky zaměřený jazyk
- Prozatím nedosahuje tak vysokého výpočetního výkonu jako C
- "Don't communicate by sharing memory; share memory by communicating"



* Klíčová slova jazyka Go
break     default      func    interface  select
case      defer        go      map        struct
chan      else         goto    package    switch
const     fallthrough  if      range      type
continue  for          import  return     var



############################################################



* Klasický program typu "Hello world"
.play sources/hello.go
.code sources/run-hello.go
.code sources/build-hello.go



* Balíčky
- každý zdrovový kód začíná deklarací `package`
- speciální balíček `main`
- main: main() pro spustitelné aplikace
- workspace je definováno v proměnné `$GOPATH`
- základní struktura: `src`, `bin`



* Funkce
- základní stavební prvek zajišťující dekompozici řešeného problému
.play sources/01-functions.go



* Více návratových hodnot
.play sources/02-functions.go



* Pojmenované návratové hodnoty
.play sources/03-functions.go



* Konstanty
.play sources/04-constants.go



* Proměnné
.play sources/05-variables.go



* Základní datové typy
- Jednoduché datové typy
- Složené datové typy
- Zvláštní datové typy



* Jednoduché datové typy
- Pravdivostní (boolean)
- Ordinální (celočíselné typy, integer)
- Neordinální (float, komplexní čísla)



* Složené datové typy
- Řetězce (string)
- Pole (array)
- Řezy (slice)
- Záznamy (struct)
- Mapy (map)



* Zvláštní datové typy
- Ukazatel (pointer)
- Funkce (function)
- Rozhraní (interface)
- Kanál (channel)



* Typová konverze
- nikdy neprobíhá automaticky
.play sources/06-casts.go



* Podmínky
- Lze deklarovat proměnné platné pouze v rámci větve s podmínkou
.play sources/07-if.go



* Větev `else`
- Lokální proměnné jsou platné i ve větvi `else`
.play sources/08-if-else.go



* Programové smyčky
- opět lze použít proměnné lokální v rámci bloku se smyčkou
- reprezentovány jediným klíčovým slovem `for`
.play sources/09-for.go



* Rozvětvení
- opět lze použít proměnné lokální v rámci bloku s rozvětvením
- testováno shora dolů, první úspěšný test vede ke spuštění větve
- nepoužívá se `break`
- naopak lze použít `fallthrough` s opačným významem
.play sources/10-switch.go



* Rozvětvení, druhá část
- neceločíselné hodnoty, nemusí se jednat o konstanty
.play sources/11-switch.go



############################################################



* Detekce a zpracování chyb
- nikoli pouze rozhodnutí "vznikla/nevznikla chyba"
- `error` je typ
[[https://blog.golang.org/error-handling-and-go]]
.play sources/12-ret.go



* Ignorování návratových hodnot/hodnoty
- použití '_' ve funkci zástupného jména proměnné
.play sources/13_ret.go



############################################################

* Příkaz `defer`
- klíčové slovo v Go
- "zapamatování" příkazů, které budou volány před skutečným opuštěním funkce
- založeno na zásobníku (LIFO, stack)
- parametry jsou vyhodnoceny ve chvíli a na místě, kdy je `defer` deklarováno v runtime
- přes `defer` lze změnit návratové hodnoty funkce



* Nejjednodušší použití příkazu `defer`
- funkce `on_finish()` je zavolána před opuštěním funkce `main()`
.play sources/14-defer-basic-usage.go



* Funkce deklarovaná přímo v `defer`
- anonymní funkce, lambda, uzávěr
.play sources/15-defer-func.go



* Funkce deklarovaná přímo v `defer` (pokračování)
- závorky okolo lambdy nejsou nutné
.play sources/16-defer-func.go



* Funkce deklarovaná přímo v `defer` (pokračování)
- specifikace argumentů předaných funkci
.play sources/17-defer-with-parameters.go



* Více příkazů `defer` v jediné funkci
- LIFO (Last In, First Out)
.play sources/18-more-defers.go



* Výpočet argumentů pro volání funkce v `defer`
.play sources/19-defer-arguments-evaluation.go



* Výpočet argumentů pro volání funkce v `defer` (pole)
.play sources/20-defer-arguments-evaluation.go



* Defer a více příkazů `return`
.play sources/21-defer-on-all-returns.go /^package main/,/^func main/



* Defer a více příkazů `return` (pokračování)
.play sources/21-defer-on-all-returns.go /^func main/,/^}/



* Praktické použití `defer`
.play sources/22-defer-practical-usage.go /^package main/,/func copyFile/



* Praktické použití `defer`
.play sources/23-defer-practical-usage.go /^func copyFile/,/^}/



* Praktické použití `defer`
.play sources/24-defer-practical-usage.go /^func main/,/^}/



* Příkaz `defer` a návratové hodnoty
- je možné měnit návratové hodnoty funkcí přes `defer`
- (funguje protože funkce deklarovaná v `defer` je uzávěr)
- návratové hodnoty funkcí musí být pojmenovány!
- velmi často používáno pro nastavení chybové hodnoty `err`



* Příkaz `defer` a návratové hodnoty
.play sources/25-defer-return-values.go



* Příkaz `defer` a návratové hodnoty
.play sources/26-defer-return-values.go



############################################################



* Struktury (záznamy)
- uživatelem definový datový typ
- nebo anonymní struktura
- pro přístup k prvkům struktury se používá operátor tečky
- inicializace v {}
- popř. se používá explicitní pojmenování prvků
- struktury lze porovnávat
- předání do funkce hodnotou nebo přes ukazatel (referencí)

* Základ práce se strukturami
.play sources/27_struct.go

* Inicializace struktur (céčkový přístup)
.play sources/28_struct_init.go

* Vylepšená inicializace
.play sources/29_better_struct_init.go

* Porovnání struktur operátory == a !=
.play sources/30_struct_comparison.go /package main/,/^func main//

* Porovnání struktur operátory == a !=
.play sources/30_struct_comparison.go /^func main/,/^}/

############################################################

* Pole (arrays)

############################################################

* Řezy (slices)

############################################################

* Ukazatele

############################################################

* Mapy

############################################################

