Nástroje implementující fronty zpráv
====================================
■ Autor    Pavel Tišnovský, Red Hat
■ Email    <ptisnovs 0x40 redhat 0x2e com>
■ Datum    2019-02-xx

Obsah přednášky
-------------------------------
▶ Message broker a fronty zpráv
▶ Proč používat tuto technologii?
▶ Modifikace architektury aplikací
▶ Základní komunikační strategie
▶ Protokoly
▶ Vybrané implementace message brokerů
▶ Redis Queue (RQ)
▶ RabbitMQ
▶ Apache Active MQ
▶ Celery
▶ Další užitečné technologie

Message broker a fronty zpráv
-------------------------------
▶ Message broker
    ◆ 
    ◆ 
    ◆ 
▶ Fronty zpráv
    ◆ 
    ◆ 
    ◆ 
▶ Topic
    ◆ 
▶ Publisher
    ◆ 
▶ Subscriber
    ◆ 
▶ Úlohy
    ◆ 
▶ Worker
    ◆ 

Proč používat tuto technologii?
-------------------------------
▶ Minimálně deset důvodů
    ◆ Asynchronní komunikace
    ◆ Oddělení jednotlivých modulů aplikace
    ◆ Možnost jasné (a centralizované) definice toku dat
    ◆ Garance doručení posílaných zpráv (popř. jejich perzistence)
    ◆ Garance pořadí zpráv
    ◆ Odolnost architektury vůči výpadkům (resiliency)
    ◆ Škálovatelnost
    ◆ Možnost snadné redundance některých částí
    ◆ Pružné reakce na změny zatížení systému (e-shopy)
    ◆ Funkce vyrovnávací paměti

Modifikace architektury aplikací
-------------------------------
▶ Možnost oddělení jednotlivých modulů
    ◆ Původní vazby M:N
        ■ Někdy "mesh"
    ◆ Nyní M:1 a 1:N

Základní komunikační strategie
-------------------------------
▶ PUSH-PULL
    ◆ Zprávy se posílají do zvolené fronty
        ■ Jeden či více zdrojů zpráv
        ■ Fronty bývají jednoznačně pojmenované
    ◆ K výstupu fronty se může připojit více workerů
    ◆ Zpráva je doručena jednomu z nich
        ■ Typicky se používá nějaká forma algoritmu round-robin
    ◆ Pokud žádný worker nemůže zprávu zpracovat zůstane ve frontě
    ◆ (Nezpracované zprávy se mohou přesunout do jiné fronty - DLQ)
▶ PUB-SUB
    ◆ Zprávy se posílají s udáním takzvaného tématu (topic)
        ■ Jeden či více zdrojů zpráv
        ■ Témata buď prosté jméno či hierarchie (cz.eshop-brno.pokladna1)
    ◆ K výstupu fronty se může připojit více příjemců
    ◆ Zpráva je doručena všem aktuálně připojeným příjemcům
    ◆ Pokud žádný příjemce nemůže zprávu zpracovat bude ztracena

Použití komunikačních strategií
-------------------------------
▶ PUSH-PULL
    ◆ Typická business logika
        ■ Objednávky
        ■ Potvrzovací maily
        ■ B2B
▶ PUB-SUB
    ◆ IoT čidla
    ◆ Aktuální stav (či změna stavu) nějakého systému
        ⇒ Tímto způsobem lze získat informace z AMQ
    ◆ Podobné některým komunikačním protokolům (IRC)

Protokoly
-------------------------------
▶ AMQP
    ◆ Advanced Message Queuing Protocol
    ◆ binární protokol
    ◆ podpora SASL a TLS
▶ STOMP
    ◆ Streaming Text Oriented Messaging Protocol
    ◆ inspirován protokolem HTTP
        ◆ (hlavičky atd.)
    ◆ velmi jednoduchá implementace klienta
▶ MQTT
    ◆ Message Queuing Telemetry Transport)
▶ CoAP
    ◆ Constrained Application Protocol
▶ WAMP
    ◆ Web Application Messaging Protocol
    ◆ založeno na WebSocketech
    ◆ Publish-Subscribe
    ◆ RPC
▶ (XMPP)
    ◆ extensible Message Oriented Middleware
    ◆ xMOM

STOMP
------------------------------------
▶ Pouze několik typů zpráv
    ◆ CONNECT
    ◆ SEND
    ◆ SUBSCRIBE
    ◆ UNSUBSCRIBE
    ◆ BEGIN
    ◆ COMMIT
    ◆ ABORT
    ◆ ACK
    ◆ NACK
    ◆ DISCONNECT

Vybrané implementace message brokerů
------------------------------------
▶ Redis Queue (RQ)
▶ RabbitMQ
▶ Apache Active MQ
▶ Celery
▶ (další užitečné technologie)

Redis Queue (RQ)
-------------------------------
▶ Postaveno nad databází Redis
    ◆ Strategie PUSH-PULL
    ◆ Publisher-fronta-worker
▶ Pravděpodobně nejjednodušší cesta k využitím message brokerů
▶ Balíček rq na PyPI
▶ CLI nástroj nazvaný `rq`
    ◆ Spuštění workera
    ◆ Pozastavení všech workerů
    ◆ Znovuspuštění úloh, které nebyly dokončeny
    ◆ Vymazání úloh z vybrané fronty
    ◆ Zobrazení stavu úloh

Redis Queue (RQ) - vytvoření úlohy
from redis import Redis
from rq import Queue
.
from worker import do_work
.
.
q = Queue(connection=Redis())
.
for i in range(10):
    result = q.enqueue(do_work, i)
    print(result)

Redis Queue (RQ) - worker
from time import sleep
.
.
def do_work(param):
    print("Working, received parameter {}".format(param))
    sleep(2)
    print("Done")

Redis Queue (RQ) - "padající" worker
from time import sleep
.
.
def do_work():
    print("Working")
    sleep(2)
    assert False
    print("Done")

Redis Queue (RQ) - info o nezpracovaných úlohách
from redis import Redis
from rq import Queue
from time import sleep

from worker import do_work


q_failed = Queue("failed", connection=Redis())

print("Reading failed jobs")

job_ids = q_failed.job_ids

print(job_ids)

for job_id in job_ids:
    print(job_id)
    job = q_failed.fetch_job(job_id)
    print(job.origin)
    print(job.enqueued_at)
    print(job.started_at)
    print(job.ended_at)
    print(job.exc_info)

Stav front
-------------------------------
$ rq info
.  
low          |██████████ 10
failed       |██ 2
default      | 0
high         |██████████ 10
4 queues, 22 jobs total
.
localhost.4312 idle: default
1 workers, 4 queues
.
Updated: 2018-11-26 13:22:06.236766

RabbitMQ
-------------------------------
▶ Jedna z nejúspěšnějších implementací brokera
▶ Vyvinut v Erlangu
    ◆ Využívá knihovny a nástroje Open Telecom Platform
    ◆ OTP
▶ Výhody Erlangu (nejenom) v této oblasti
    ◆ Odolnost proti selhání
    ◆ Vysoce dostupné aplikace
    ◆ Distribuované systémy
    ◆ Funkcionální paradigma

RabbitMQ
-------------------------------
▶ Rozhraní pro programovací jazyky (platformy)
    ◆ Java
    ◆ JavaScript (Node.js)
    ◆ Python
    ◆ Ruby
    ◆ PHP
    ◆ C#
    ◆ Go
    ◆ Elixir
    ◆ (Java) Spring AMQP
    ◆ Swift
    ◆ Objective-C
    ◆ Clojure

RabbitMQ
-------------------------------
▶ Podporované protokoly
    ◆  AMQP
        ■ verze 0-9-1
        ■ 0-9
        ■ 0-8
    ◆  STOMP
    ◆  MQTT

RabbitMQ
-------------------------------
▶ Směrování zpráv před jejich vložením do fronty
▶ Strategie
    ◆  Direct
        ■ fronta nalezena podle klíče
        ■ klíč je součástí zprávy
    ◆  Topic
        ■ opět se používá klíč
        ■ využití regulárních výrazů
        ■ hierarchie front atd.
    ◆  Headers
        ■ využívá hlavičky připojené ke zprávě
    ◆  Fanout
        ■ zduplikování zprávy do několika front
        ■ (přeposlání na různé servery)

RabbitMQ a Python
-------------------------------
▶  Knihovna Pika
    ◆  Na PyPi
        ■ https://pypi.org/project/pika/

Publisher pro RabbitMQ a Pika
-------------------------------
import pika
.
# připojení k serveru RabbitMQ a vytvoření komunikačního kanálu
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
.
# žádost o vytvoření či o použití fronty „test“
channel.queue_declare(queue='test')
.
# poslání zprávy se strategií direct
channel.basic_publish(exchange='',
                      routing_key='test',
                      body='Hello World!')
. 
print("Sent 'Hello World!'")
# uzavření komunikace
connection.close()

Apache Active MQ
-------------------------------
▶
▶
▶

Celery
-------------------------------
▶
▶
▶

Další užitečné technologie
-------------------------------
▶
▶
▶
