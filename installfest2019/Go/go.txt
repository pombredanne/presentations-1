Jazyk Go pro úplné začátečníky
==============================
■ Autor    Pavel Tišnovský, Red Hat
■ Email    <ptisnovs 0x40 redhat 0x2e com>
■ Datum    2019-03-01

Obsah přednášky
-------------------------------
▶ Charakteristické rysy jazyka Go
▶ Struktura programů psaných v Go
▶ Klíčová slova jazyka Go
▶ Základní datové typy
▶ Uživatelské datové typy
▶ Operátory
▶ Deklarace funkcí
▶ Řídicí příkazy
▶ Reakce na chybové stavy
▶ Rozhraní
▶ Metody
▶ Gorutiny
▶ Kanály
▶ Balíčky
▶ Základní knihovna programovacího jazyka Go
    ◆ Užitečné balíčky

Last minute info
--------------------------------------------------
▶ 25.2.2019 vyšla verze Go 1.12
▶ žádné podstatné změny v jazyku
    ◆ nástroje
    ◆ knihovny

Charakteristické rysy jazyka Go
--------------------------------------------------
„Less is more“
▶ Multiparadigmatický jazyk
    ◆ Procedurální
    ◆ Objekově orientovaný
    ◆ Podpora konstrukcí pro paralelní programování
▶ Vznik
    ◆ Snaha o přidání konstrukcí pro paralelní programování do C++
    ◆ Serverové aplikace pro Google
▶ Dostupný pro všechny „zajímavé“ systémy
    ◆ Linux, (Free)BSD, macOS, Microsoft Windows
▶ Pro běžné architektury
    ◆ x86 i x86-64
    ◆ ARMv6
    ◆ ARMv8
▶ I pro ty více exotické
    ◆ s390x
    ◆ PowerPC64 (LE)
▶ Současná verze používá vlastní backend
    ◆ + cgo

Charakteristické rysy jazyka Go
--------------------------------------------------
▶ Cíle
    ◆ Jednoduchost, jednoznačnost
    ◆ Jazyk postaven na jednoduchých a známých konceptech
        ⇒ Lze začít programovat po doslova několikaminutovém tutoriálu
        ⇒ Ovšem pokročilejší vlastnosti je potřeba nastudovat
    ◆ Bezpečné aplikace
    ◆ Mikroslužby
    ◆ Skripty a nástroje pro DevOps od DevOps
    ◆ Jazyk původně pro potřeby Googlu:
        ⇒ spíše pro mladší vývojáře
          (C/C++, Java, Python ve škole)
    ◆ Použití pro rozsáhlejší aplikace psané velkým týmem
    ◆ Paralelní běh částí aplikace
        ⇒ komunikace mezi paralelně běžícími částmi
    ◆ Rozumný výpočetní výkon
        ⇒ cílem je dosáhnout výkonnosti C/C++/Fortranu
    ◆ Rychlý překlad
        ⇒ CI/CD
        ⇒ lokální vývoj i rozsáhlých systémů

Charakteristické rysy jazyka Go (2)
--------------------------------------------------
× Poučení z chyb, které najdeme například v C/C++
    ◆ Silný typový systém
        ⇒ explicitní konverze
    ◆ Nepoužívají se makra založená na textové substituci
    ◆ Nepoužívají se hlavičkové soubory
    ◆ Systém balíčků, kontrola použití balíčků
    ◆ Bezpečná práce s pamětí (+ GC)
    ◆ Standardizovaný framework pro testování
    ◆ Rychlé překlady
    ◆ Syntaktické věci: ++/-- jen postfixové a nejsou to výrazy
    ◆ Nepoužívá se ukazatelová aritmetika tak jako v C
        ⇒ práce s ukazateli je do značné míry omezena
    ◆ Nepoužívají se šablony
    ◆ Nejsou podporovány výjimky (prozatím)

Charakteristické rysy jazyka Go (3)
--------------------------------------------------
▶ Správa paměti se přenáší do runtime
▶ Gorutiny a kanály
    ◆ 600k gorutin, 90% CPU
▶ Typový systém
    ◆ Snadné vytváření nových typů
    ◆ Generické datové typy
        ■ chystají se
        ■ po stabilizaci jazyka (což nastalo)
        ■ Go 2?
▶ Více imperativních rysů
    ◆ Explicitní zápis většiny operací
▶ Neexistuje podpora pro generické datové typy
    ◆ Pravděpodobně se změní v další verzi Go
▶ Pragmaticky zaměřený jazyk
▶ Prozatím nedosahuje tak vysokého výpočetního výkonu jako C

Charakteristické rysy jazyka Go (4)
--------------------------------------------------
▶ Výsledkem překladu může být binární soubor obsahující vše potřebné
    ⇒ jednodušší distribuce
    ⇒ "DLL hell"
    ⇒ Docker atd.
    ⇒ cross překlad

Klíčová slova jazyka Go
--------------------------------------------------
break     default      func    interface  select
case      defer        go      map        struct
chan      else         goto    package    switch
const     fallthrough  if      range      type
continue  for          import  return     var

Základní datové typy
--------------------------------------------------
▶ Jednoduché datové typy
    ◆ Pravdivostní
         ■ Pravdivostní typ (boolean)
    ◆ Ordinální
         ■ Celočíselné typy (integer)
    ◆ Neordinální
         ■ Hodnoty s plovoucí řádovou čárkou (float)
         ■ Komplexní čísla (complex)
▶ Složené datové typy
    ◆ Řetězce (string)
    ◆ Pole (array)
    ◆ Řezy (slice)
    ◆ Záznamy (struct)
    ◆ Mapy (map)
▶ Zvláštní datové typy
    ◆ Ukazatel (pointer)
    ◆ Funkce (function)
    ◆ Rozhraní (interface)
    ◆ Kanál (channel)

Pravdivostní typ
--------------------------------------------------
▶ bool
    ◆ true
    ◆ false
▶ neprovádí se automatická konverze z/na int!

Celočíselné datové typy
--------------------------------------------------
▶ nezávislé na použité architektuře
▶ implicitní (výchozí) hodnota = 0
  
Označení          Od                   Do           Stručný popis
int8                     -128                  127  osmibitové celé číslo se znaménkem
int16                  -32768                32767  16bitové celé číslo se znaménkem
int32             -2147483648           2147483647  32bitové celé číslo se znaménkem
int64    -9223372036854775808  9223372036854775807  64bitové celé číslo se znaménkem
  
uint8                       0                  255  osmibitové celé číslo bez znaménka
uint16                      0                65535  16bitové celé číslo bez znaménka
uint32                      0           4294967295  32bitové celé číslo bez znaménka
uint64                      0 18446744073709551615  64bitové celé číslo bez znaménka
  
int                     různý                různý  odpovídá buď typu int32 nebo int64
uint                    různý                různý  odpovídá buď typu uint32 nebo uint64
  
byte                        0                  255  alias pro typ uint8
rune              -2147483648           2147483647  alias pro typ int32

Celočíselné datové typy
--------------------------------------------------
        var a int8 = -10
        var b int16 = -1000
        var c int32 = -10000
        var d int32 = -1000000
  
        var r1 rune = 'a'
        var r2 rune = '\x40'
        var r3 rune = '\n'
        var r4 rune = '\u03BB'
  
        var x uint8 = 10
        var y uint8 = 010
        var z uint8 = 0x10

Explicitní konverze!
--------------------------------------------------
        var a int8 = -10
        var signed_int int32 = -100000
        var unsigned_int uint32 = 100000
        var e float32 = 1e4
        var f float64 = 1.5e30

        var x int32 = int32(a)
        var y int32 = int32(e)
        var z float32 = float32(f)

        var b2 uint8 = uint8(signed_int)
        var b3 uint8 = uint8(unsigned_int)

Neordinální celočíselné datové typy
--------------------------------------------------
▶ opět nezávislé na použité architektuře
▶ implicitní (výchozí) hodnota = 0.0
  
Označení        Rozsah hodnot                          Stručný popis
float32         -3,4×10³⁸ až 3,4×10³⁸                  číslo s jednoduchou přesností podle IEEE 754
float64         -1,7×10³⁰⁸ až 1,7×10³⁰⁸                číslo s dvojitou přesností podle IEEE 754
complex64       ± rozsah float32 + i ± rozsah float32  dvojice hodnot s jednoduchou přesností
complex128      ± rozsah float64 + i ± rozsah float64  dvojice hodnot s dvojitou přesností

Neordinální celočíselné datové typy
--------------------------------------------------
        var a float32 = -1.5
        var b float32 = 1.5
        var c float32 = 1e30
        var d float32 = 1e-30
 
        var x complex64 = -1.5 + 0i
        var y complex64 = 1.5 + 1000i
        var z complex64 = 1e30 + 1e30i
        var w complex64 = 1i

Řetězce (string)
--------------------------------------------------
▶ Řetězce (string)
    ◆ podpora Unicode
    ◆ neměnitelné (immutable)
    ◆ známá délka (žádné počítání indexu \0)
        ⇒ ovšem udávaná v bajtech, nikoli ve znacích.
    ◆ [] - přístup k bajtům, ne ke znakům
    ◆ podpora konverze na byte[]
  
        fmt.Println("╭─────────────────────╮")
        fmt.Println("│ příλiš žλuťΩučký kůň│")
        fmt.Println("╰─────────────────────╯")

Pole bajtů tvořících řetězec
--------------------------------------------------
        var s string = "Hello\nworld!\nžluťoučký kůň"
   
        for i := 0; i < len(s); i++ {
                fmt.Printf("%02x ", s[i])
        }

Pole (array)
--------------------------------------------------
▶ Pole (array)
    ◆ měnitelné (mutable)
    ◆ konstantní počet prvků
    ◆ automatická inicializace prvků (na "nulu")
  
        var a1 [10]byte
        a2 := [10]int32{1,10,2,9,3,8,4,7,5,6}
        var matice [10][10]float32
 
        for i:= 0; i < len(a1); i++ {
                a[i] = i*2;
        }

Kopie polí
--------------------------------------------------
        a2 := a1
 
▶ V Go se provede skutečná kopie pole
    ◆ výsledkem budou dvě na sobě nezávislá pole.
▶ V Javě (například) se jen přiřadí reference
    ◆ dvě proměnné budou ukazovat na stejné pole.

Řezy (slice)
--------------------------------------------------
▶ Řezy (slice)
    ◆ neobsahuje přímo prvky, ale pouze referencuje existující pole
    ◆ podpora pro operaci "slice" pole[od:do]
    ◆ podpora pro přidání prvků na konec řezu
        ■ interně může dojít ke realokaci pole/vytvoření nového pole
    ◆ interní struktura
        ■ ukazatel na prvek pole 
        ■ délka (počet prvků)
        ■ kapacita
    ◆ funkce
        ■ make
        ■ copy
        ■ append

Řezy (slice)
--------------------------------------------------
        a := [6]string{"C", "C++", "Java", "Python", "Go", "Rust"}
  
        slice1 := a[1:4]
        slice2 := a[:3]
        slice3 := a[2:]
        slice4 := a[:]
  
        fmt.Println("Array a =", a)
        fmt.Println("slice1 =", slice1)
        fmt.Println("slice2 =", slice2)
        fmt.Println("slice3 =", slice3)
        fmt.Println("slice4 =", slice4)

Řezy (slice)
--------------------------------------------------
▶ Výstup bude vypadat následovně:
Array a = [C C++ Java Python Go Rust]
slice1 = [C++ Java Python]
slice2 = [C C++ Java]
slice3 = [Java Python Go Rust]
slice4 = [C C++ Java Python Go Rust]

Uživatelsky definované datové typy
--------------------------------------------------
package main
  
import "fmt"
  
type Id uint32
type Name string
type Surname string
  
func register_user(id Id, name Name, surname Surname) {
        fmt.Printf("Registering: %d %s %s", id, name, surname)
}
  
func main() {
        var i Id = 1
        var n Name = "Jan"
        var s Surname = "Novák"
   
        register_user(i, n, s)
}

Operátor :=
--------------------------------------------------
▶ Význam operátoru :=
    ◆ deklarace proměnné
    ◆ určení jejího typu
    ◆ inicializace proměnné
  
        a := 10
        fmt.Println(a)
        b := "hello"
        fmt.Println(b)
        c := true
        fmt.Println(c)

Operátor :=
--------------------------------------------------
▶ Pokud je proměnná deklarována
    ◆ není ji možné v daném bloku deklarovat znovu
    ◆ tudíž ani není možné použít znovu přiřazení :=.

Záznamy (struct)
--------------------------------------------------
▶ Záznamy (struct)
    ◆ viditelnost prvků podle prvního znaku názvu
    ◆ přístup k prvkům s využitím tečkové notace
 
Záznamy (struct)
--------------------------------------------------
type User struct {
        id      uint32
        name    string
        surname string
}
   
var user1 User
   
user1.id = 1
user1.name = "Pepek"
user1.surname = "Vyskoč"
 
Tisk obsahu záznamů a inicializace záznamů
--------------------------------------------------
▶ Záznamy je možné vytisknout s využitím funkce fmt.Println:
 
fmt.Println(user1)
 
▶ Inicializace záznamů
user1 := User{
        1,
        "Pepek",
        "Vyskoč"}

Pole záznamů
--------------------------------------------------
var users = [3]User{
        User{
                id:      1,
                name:    "Pepek",
                surname: "Vyskoč"},
        User{
                id:      2,
                name:    "Pepek",
                surname: "Vyskoč"},
        User{
                id:      3,
                name:    "Josef",
                surname: "Vyskočil"},
}

Mapy (map)
--------------------------------------------------
▶ Mapy (map)
    ◆ též asociativní pole
    ◆ heše/hashe
▶ Tzv. nil map
    ◆ var m1 map[int]string
    ◆ var m2 map[string]User
▶ Prázdná mapa
    ◆ var m3 map[int]string = make(map[int]string)
    ◆ m1 := make(map[int]string)
▶ Přidání položek do prázdné mapy
    ◆ m3[0] = "nula"
    ◆ m3[1] = "jedna"
    ◆ m3[2] = "dva"
    ◆ m3[3] = "tri"

Operace s mapami
--------------------------------------------------
▶ Přečtení hodnoty z mapy
    ◆ value, exist := mapa[klíč]
 
if exist {
        // prvek byl nalezen
} else {
        // prvek nebyl nalezen
}
 
▶ Vymazání hodnot z map
    ◆ delete(mapa, klíč)

Mapy a struktury
--------------------------------------------------
type User struct {
        id      uint32
        name    string
        surname string
}
 
func main() {
        m1 := make(map[string]User)
        fmt.Println(m1)

        m1["prvni"] = User{
                id:      1,
                name:    "Pepek",
                surname: "Vyskoč"}

        m1["druhy"] = User{
                id:      2,
                name:    "Josef",
                surname: "Vyskočil"}

        fmt.Println(m1)
}

Mapy a struktury, klíče jako uživatelský typ
--------------------------------------------------
type Key struct {
        id   uint32
        role string
}
 
type User struct {
        id      uint32
        name    string
        surname string
}
 
func main() {
        m1 := make(map[Key]User)
        fmt.Println(m1)
 
        m1[Key{1, "admin"}] = User{
                id:      1,
                name:    "Pepek",
                surname: "Vyskoč"}
 
        m1[Key{2, "user"}] = User{
                id:      2,
                name:    "Josef",
                surname: "Vyskočil"}
 
        fmt.Println(m1)
}

Zvláštní datové typy
--------------------------------------------------

Ukazatele
--------------------------------------------------

Operátory
--------------------------------------------------
aritmetické                +   -   *   /   %
aritmetické s přiřazením   +=  -=  *=  /=  %=
logické                    &&  ||  !
posuny a bitové operace    <<  >>  &   |   ^   &^
-//- s přiřazením          <<= >>= &=  |=  ^=  &^=
relační                    ==  !=  <   <=  >   >=
operace s adresami         *   &
unární operátory           +   -   ^
další operátory            <-  :=

Deklarace funkcí
--------------------------------------------------
▶ Funkce bez parametrů a bez návratové hodnoty
func printHello() {
        fmt.Println("Hello world!")
}
  
▶ Funkce s jedním parametrem, bez návratové hodnoty
func printMessage(message string) {
        fmt.Println(message)
}
    
▶ Funkce s jednou návratovou hodnotou
func getMessage() string {
        return "Hello world!"
}
  
▶ Alternativní zápis
func getMessage() (message string) {
        message = "Hello world!"
        return
}
 
▶ Více návratových hodnot
func swap(a int, b int) (int, int) {
        return b, a
}

Staticky typovaný jazyk bez zbytečného "boilerplate"
----------------------------------------------------
func swap(a int, b int) (int, int) {
        return b, a
}
  
        x := 1
        y := 2
        z, w := swap(x, y)

Řidící příkazy
--------------------------------------------------
▶ Příkaz return
▶ Rozhodovací konstrukce
▶ Programové smyčky
▶ Příkaz goto
▶ Speciální řízení (defer)

Příkaz return
--------------------------------------------------

Rozhodovací konstrukce
--------------------------------------------------

Programové smyčky
--------------------------------------------------

Příkaz goto
--------------------------------------------------

Speciální řízení (defer)
--------------------------------------------------

Reakce na chybové stavy
--------------------------------------------------
▶ 
▶ 
▶ 

Rozhraní
--------------------------------------------------
▶ 
▶ 
▶ 

Metody
--------------------------------------------------
▶ 
▶ 
▶ 

Gorutiny
--------------------------------------------------
▶ 
▶ 
▶ 

Kanály
--------------------------------------------------
▶ 
▶ 
▶ 

Balíčky
--------------------------------------------------
▶ klíčové slovo package 
▶ import balíčků přes příkaz import "název_balíčku"
▶ 

Základní knihovna programovacího jazyka Go
--------------------------------------------------
▶ 
▶ 
▶ 

Makra v Go?
--------------------------------------------------
▶ Céčkový přístup:
    ◆ řeší preprocesor
        #ifdef _DEBUG
        puts("something");
        #else
        puts("something else");
        #endif
▶ Částečně nahraditelná:
    ◆ řeší překladač
        const debug = false
        if debug {
            fmt.Println("something")
        } else {
            fmt.Println("something else")
        }

Look and feel Go
--------------------------------------------------
func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }
    defer src.Close()
 
    dst, err := os.Create(dstName)
    if err != nil {
        return
    }
    defer dst.Close()
 
    return io.Copy(dst, src)
}

Poznámky
--------------------------------------------------
▶ Okolo podmínek nejsou závorky
▶ Nepovinný středník
▶ nil
▶ Více návratových hodnot
▶ Chyba je poslední navrácenou hodnotou, konvence
▶ Použití defer, viz další slajd
▶ Zkrácený zápis deklarace a inicializace lokálních proměnných
    var src, err...
    src, err := ...
▶ Pojmenované návratové hodnoty (nepovinné)

Klíčové slovo defer
--------------------------------------------------
▶ defer - přidání volání do zásobníku
▶ Funkce ze zásobníku se zavolají po ukončení aktivní funkce
▶ Skutečné LIFO chování
▶ Parametry se vyhodnocují v čase volání defer
    ◆ ne při vlastním voláni funkce (to je pozdě :-)
▶ Funkce volaná přes defer může měnit návratové kódy "hlavní" funkce
    ◆ musí být pojmenovány

Zpracování chybových stavů
--------------------------------------------------
type error interface {
    Error() string
}
.
func div(x, y int32) (int32, error) {
        if y == 0 {
                return -1, errors.New("takto ne!")
        }
        return x / y, nil
}
.
func main() {
        res, err := div(10, 3)
        fmt.Println(res, err)
        res, err = div(10, 0)
        fmt.Println(res, err)
}

Gorutiny
--------------------------------------------------
func f(from string) {
    for i := 0; i < 3; i++ {
        fmt.Println(from, ":", i)
    }
}
.
func main() {
    f("direct")
    go f("goroutine")
    go func(msg string) {
        fmt.Println(msg)
    }("going")

    fmt.Scanln()
    fmt.Println("done")
}
.
func main() {
    messages := make(chan string)
    go func() { messages <- "ping" }()
    msg := <-messages
    fmt.Println(msg)
}

Jednoduchá synchronizace v Go
------------------------------------
func worker(done chan bool) {
    fmt.Print("working...")
    time.Sleep(time.Second)
    fmt.Println("done")

    // ok uz jsme hotovi, posleme zpravu kanalem
    done <- true
}
.
func main() {
    // kanal s kapacitou == 1
    done := make(chan bool, 1)
.
    // asynchronni beh
    go worker(done)
.
    // cekame na zpravu
    <-done
}

A samozřejmě oblíbené téma pro debaty...
--------------------------------------------------
▶ Formát zápisu programů
    ◆ autoři Go: lepší je se soustředit na vlastní vývoj
    ◆ Definován kanonický formát
        - gofmt
        - taby atd.:)
